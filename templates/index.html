<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YOLO Polygon Labeler</title>
  <style>
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 0; 
      height: 100vh; 
      overflow: hidden;
      background: #2a1a3a;
    }
    
    #canvas-container { 
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    canvas { 
      cursor: crosshair; 
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      touch-action: none; /* Prevent default touch behaviors */
      -ms-touch-action: none; /* IE/Edge support */
    }
    
    #left-toolbox {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 6px;
      border-radius: 4px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100px;
    }
    
    #bottom-status-bar {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0, 0, 0.9);
      padding: 4px 12px;
      border-radius: 4px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      z-index: 1000;
    }
    
    .status-left {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex: 1;
    }
    
    .status-center {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
    }
    
    .status-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      justify-content: flex-end;
    }
    
    .legend {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 15px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 10px;
      color: #ccc;
    }
    
    .legend-dot {
      font-size: 8px;
    }
    
    #image-filename {
      color: #4a90e2;
      font-weight: bold;
      margin-left: 10px;
      white-space: nowrap;
    }
    
    #status-message {
      color: #4a90e2;
    }
    
    #status-message.error {
      color: #ff4444;
    }
    
    #right-toolbox {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 6px;
      border-radius: 4px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100px;
    }
    
    .toolbox-section {
      margin-bottom: 10px;
    }
    
    .toolbox-section:last-child {
      margin-bottom: 0;
    }
    
    .toolbox-section h3 {
      color: white;
      margin: 0 0 5px 0;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button { 
      padding: 5px 4px; 
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 500;
      transition: all 0.2s;
      width: 100%;
      margin-bottom: 3px;
    }
    
    button:last-child {
      margin-bottom: 0;
    }
    
    .action-btn {
      background: #4a90e2;
      color: white;
    }
    
    .action-btn:hover {
      background: #357abd;
    }
    
    .class-btn {
      background: #666;
      color: white;
      padding: 4px 3px;
      font-size: 9px;
      border: 1px solid transparent;
      text-align: left;
    }
    
    .class-btn:hover {
      background: #888;
    }
    
    .class-btn.active {
      border: 2px solid white;
    }
    
    /* Class-specific colors will be generated dynamically */
    
    .nav-btn {
      background: #28a745;
      color: white;
    }
    
    .nav-btn:hover {
      background: #218838;
    }
    
    #image-list {
      max-height: 200px;
      overflow-y: auto;
      border-radius: 3px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Custom scrollbar for image list */
    #image-list::-webkit-scrollbar {
      width: 6px;
    }
    
    #image-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    
    #image-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    
    #image-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    .image-item {
      display: flex;
      align-items: center;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 11px;
      color: #ccc;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .image-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .image-item.current {
      background: rgba(106, 76, 147, 0.8); /* Purple with less transparency */
      color: white;
    }
    
    .label-icon {
      width: 12px;
      height: 12px;
      margin-right: 6px;
      flex-shrink: 0;
    }
    
    .image-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-grow: 1;
    }
    
    #status {
      color: #4a90e2;
      font-size: 9px;
      margin: 0;
      text-align: center;
      padding: 4px;
      background: rgba(74, 144, 226, 0.1);
      border-radius: 2px;
      border: 1px solid rgba(74, 144, 226, 0.3);
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>

  <div id="left-toolbox">
    <div class="toolbox-section">
      <h3>Actions</h3>
      <button id="saveBtn" class="action-btn">Save (S)</button>
      <button id="undoPointBtn" class="action-btn">Undo (Z)</button>
      <button id="deletePolyBtn" class="action-btn">Delete (X)</button>
    </div>
    
    <div class="toolbox-section">
      <h3>Zoom</h3>
      <button id="zoomOutBtn" class="action-btn">Zoom Out (-)</button>
      <button id="zoomInBtn" class="action-btn">Zoom In (=)</button>
      <button id="resetZoomBtn" class="action-btn">Reset (R)</button>
    </div>
    
    <div class="toolbox-section">
      <h3>Navigation</h3>
      <button id="prevBtn" class="nav-btn">Back (B)</button>
      <button id="nextBtn" class="nav-btn">Next (N)</button>
      <div id="image-list">
        <!-- Image list will be populated here -->
      </div>
    </div>
    
  </div>

  <div id="right-toolbox">
    <div class="toolbox-section">
      <h3>Classes</h3>
      <div id="classButtons">
        <!-- Class buttons will be generated here -->
      </div>
    </div>
  </div>

  <!-- Bottom Status Bar -->
  <div id="bottom-status-bar">
    <div class="status-left">
      <div class="legend">
        <span class="legend-item"><span class="legend-dot" style="color: #28a745;">●</span>Complete</span>
        <span class="legend-item"><span class="legend-dot" style="color: #ffe066;">●</span>Partial</span>
        <span class="legend-item"><span class="legend-dot" style="color: #fd7e14;">●</span>Incomplete</span>
        <span class="legend-item"><span class="legend-dot" style="color: #6c757d;">○</span>Empty</span>
      </div>
    </div>
    <div class="status-center">
      <span id="status-message"></span>
    </div>
    <div class="status-right">
      <span id="zoom-info">Zoom: 100%</span>
      <span id="polygon-count">Polygons: 0</span>
      <span id="image-filename"></span>
    </div>
  </div>

  <script>
let classes = [];
let images = [];
let currentImageIndex = 0;
let currentImage = null;
let polygons = [];  // {class_id, points:[{x,y}]}
let activePoly = null;
let draggingPoint = null;
let temporaryPoint = null;  // Point that follows mouse until mouse up
let selectedClassId = 0;

// Zoom and pan state
let zoom = 1;
let panX = 0;
let panY = 0;
let isPanMode = false;   // true when space held
let isDraggingPan = false;
let lastPanX = 0;
let lastPanY = 0;

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// ===== Color Generation =====
function generateClassColor(classIndex) {
  // Generate a color using HSL for better distribution
  const hue = (classIndex * 137.5) % 360; // Golden angle for good distribution
  const saturation = 70 + (classIndex % 3) * 10; // Vary saturation slightly
  const lightness = 45 + (classIndex % 2) * 10; // Vary lightness slightly
  
  // Convert HSL to RGB
  const h = hue / 360;
  const s = saturation / 100;
  const l = lightness / 100;
  
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs((h * 6) % 2 - 1));
  const m = l - c / 2;
  
  let r, g, b;
  if (h < 1/6) { r = c; g = x; b = 0; }
  else if (h < 2/6) { r = x; g = c; b = 0; }
  else if (h < 3/6) { r = 0; g = c; b = x; }
  else if (h < 4/6) { r = 0; g = x; b = c; }
  else if (h < 5/6) { r = x; g = 0; b = c; }
  else { r = c; g = 0; b = x; }
  
  r = Math.round((r + m) * 255);
  g = Math.round((g + m) * 255);
  b = Math.round((b + m) * 255);
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// ===== Load classes and images =====
async function init() {
  classes = await fetch("/classes").then(r => r.json());
  images = await fetch("/images").then(r => r.json());

  // Create class buttons with dynamic colors
  let classButtons = document.getElementById("classButtons");
  classes.forEach((c, i) => {
    let btn = document.createElement("button");
    btn.className = "class-btn";
    btn.setAttribute("data-class", i);
    btn.textContent = `${i + 1}: ${c}`;
    btn.style.backgroundColor = generateClassColor(i);
    btn.onclick = () => selectClass(i);
    classButtons.appendChild(btn);
  });

  // Select first class by default
  selectClass(0);
  loadImage(0);
  
  // Populate image list navigation
  populateImageList();
}

// ===== Image List Navigation =====
let imageListUpdateTimeout = null;
let isPopulatingImageList = false;

function debounceUpdateImageList() {
  if (imageListUpdateTimeout) {
    clearTimeout(imageListUpdateTimeout);
  }
  imageListUpdateTimeout = setTimeout(() => {
    populateImageList();
    imageListUpdateTimeout = null;
  }, 300); // 300ms debounce
}

async function populateImageList() {
  if (isPopulatingImageList) return; // Prevent concurrent calls
  isPopulatingImageList = true;
  const imageListElement = document.getElementById('image-list');
  
  // Save scroll position
  const scrollTop = imageListElement.scrollTop;
  
  imageListElement.innerHTML = '';
  
  // Get label status for all images at once
  let labelStatusMap = {};
  try {
    const response = await fetch('/label-status-all');
    labelStatusMap = await response.json();
  } catch (e) {
    console.log('Could not fetch label status, defaulting to false');
    labelStatusMap = {};
  }
  
  for (let i = 0; i < images.length; i++) {
    const imageName = images[i];
    const status = labelStatusMap[imageName] || "none";
    
    // Create image item element
    const item = document.createElement('div');
    item.className = 'image-item';
    item.setAttribute('data-index', i);
    if (i === currentImageIndex) {
      item.classList.add('current');
    }
    
    // Add label icon
    const icon = document.createElement('span');
    icon.className = 'label-icon';
    if (status === "green") {
      icon.innerHTML = '●'; // Filled circle for all classes present
      icon.style.color = '#28a745'; // Green - all classes present
    } else if (status === "yellow") {
      icon.innerHTML = '●'; // Filled circle for X+ polygons but missing classes
      icon.style.color = '#ffe066'; // Yellow - X+ polygons but not all classes
    } else if (status === "orange") {
      icon.innerHTML = '●'; // Filled circle for some classes missing
      icon.style.color = '#fd7e14'; // Orange - missing classes
    } else {
      icon.innerHTML = '○'; // Empty circle for unlabeled
      icon.style.color = '#6c757d'; // Gray
    }
    
    // Add image name
    const name = document.createElement('span');
    name.className = 'image-name';
    name.textContent = imageName;
    
    item.appendChild(icon);
    item.appendChild(name);
    item.onclick = () => navigateToImage(i);
    
    imageListElement.appendChild(item);
  }
  
  // Restore scroll position
  imageListElement.scrollTop = scrollTop;
  
  isPopulatingImageList = false;
}

function navigateToImage(index) {
  loadImage(index);
  updateImageListCurrent();
}

function updateImageListCurrent() {
  const items = document.querySelectorAll('.image-item');
  items.forEach((item, index) => {
    item.classList.toggle('current', index === currentImageIndex);
  });
}

// ===== Class Selection =====
function selectClass(classId) {
  selectedClassId = classId;
  // Update button states
  document.querySelectorAll('.class-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === classId);
  });
}

async function loadImage(idx) {
  if (idx < 0 || idx >= images.length) return;
  
  // Auto-save before changing images if there are polygons
  if (polygons.length > 0) {
    save();
  }
  
  currentImageIndex = idx;
  polygons = [];
  // Keep zoom and pan state persistent across images
  // zoom = 1;
  // panX = 0;
  // panY = 0;
  
  const img = new Image();
  img.onload = async () => {
    currentImage = img;
    // Set canvas size to fill viewport
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Load existing labels for this image
    await loadExistingLabels(images[currentImageIndex]);
    
    // Update image list current indicator
    updateImageListCurrent();
    
    // Update status bar
    updateStatusBar();
    
    // Force multiple redraws to ensure proper image display
    requestAnimationFrame(() => {
      draw();
      requestAnimationFrame(() => {
        draw();
        requestAnimationFrame(() => {
          // One more draw after a brief delay to ensure image is visible
          setTimeout(() => draw(), 50);
        });
      });
    });
  };
  img.src = "/image/" + images[idx];
}

// ===== Load Existing Labels =====
async function loadExistingLabels(imageName) {
  try {
    const response = await fetch(`/load/${imageName}?t=${Date.now()}`);
    const annotations = await response.json();
    
    // Calculate image display dimensions (same logic as in draw function)
    let imageWidth, imageHeight, imageX, imageY;
    if (currentImage) {
      const imageAspect = currentImage.width / currentImage.height;
      const canvasAspect = canvas.width / canvas.height;
      
      if (imageAspect > canvasAspect) {
        // Image is wider - fit to width
        imageWidth = canvas.width;
        imageHeight = canvas.width / imageAspect;
        imageX = 0;
        imageY = (canvas.height - imageHeight) / 2;
      } else {
        // Image is taller - fit to height
        imageHeight = canvas.height;
        imageWidth = canvas.height * imageAspect;
        imageX = (canvas.width - imageWidth) / 2;
        imageY = 0;
      }
    }
    
    // Convert normalized coordinates back to canvas coordinates using image display area
    polygons = annotations.map(ann => ({
      class_id: ann.class_id,
      points: ann.points.map(pt => ({
        x: imageX + (pt[0] * imageWidth),
        y: imageY + (pt[1] * imageHeight)
      }))
    }));
    
    // Clear active polygon since we're loading existing ones
    activePoly = null;
    
    console.log(`Loaded ${polygons.length} existing polygons for ${imageName}`);
  } catch (error) {
    console.error('Error loading existing labels:', error);
    polygons = [];
  }
}

// ===== Mouse Events =====
canvas.addEventListener("mousedown", (e) => {
  console.log("MOUSE DOWN");
  if (isPanMode) return;

  const {x,y} = getMouse(e);
  const hitRadius = 5 / zoom;
  
  // First check if clicking on the start point of the active polygon to close it
  if (activePoly && activePoly.points.length >= 3) {
    const firstPoint = activePoly.points[0];
    if (dist(x,y,firstPoint.x,firstPoint.y) < hitRadius) {
      // Close the polygon
      activePoly = null;
      draw();
      save();
      return;
    }
  }
  
  // Check if clicking near any existing point
  for (let poly of polygons) {
    for (let pt of poly.points) {
      if (dist(x,y,pt.x,pt.y) < hitRadius) {
        console.log("Clicked on existing point to edit");
        draggingPoint = pt;
        activePoly = poly;
        // Remove saved state when editing a polygon
        removeSavedState();
        return;
      }
    }
  }
  
  // Else: Start new polygon and create temporary point
  if (!activePoly) {
    activePoly = {class_id: selectedClassId, points: []};
    polygons.push(activePoly);
  }
  
  // Create temporary point that will follow mouse
  temporaryPoint = {x, y};
  console.log("Creating new temporary point at:", {x, y});
  draw();
});

canvas.addEventListener("mousemove", (e) => {
  if (temporaryPoint) {
    // Update temporary point to follow mouse
    const {x,y} = getMouse(e);
    temporaryPoint.x = x;
    temporaryPoint.y = y;
    draw();
  } else if (draggingPoint) {
    // Drag existing point
    const {x,y} = getMouse(e);
    draggingPoint.x = x;
    draggingPoint.y = y;
    draw();
  }
});

canvas.addEventListener("mouseup", () => {
  console.log("MOUSE UP");
  if (temporaryPoint) {
    console.log("Adding temporary point to polygon at:", temporaryPoint);
    // Add temporary point to polygon at current position
    activePoly.points.push({x: temporaryPoint.x, y: temporaryPoint.y});
    temporaryPoint = null;
    draw();
  }
});

// ===== Zoom =====
canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));

  // Adjust pan so zoom is centered at mouse
  const zoomRatio = newZoom / zoom;
  panX = mouseX - (mouseX - panX) * zoomRatio;
  panY = mouseY - (mouseY - panY) * zoomRatio;
  zoom = newZoom;
  updateZoomInfo();

  // Force multiple redraws to prevent artifacts
  requestAnimationFrame(() => {
    draw();
    requestAnimationFrame(() => {
      draw();
    });
  });
});

// Touch support for pinch zoom
let lastTouchDistance = 0;
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    lastTouchDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
  }
});

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
    
    if (lastTouchDistance > 0) {
      const zoomFactor = currentDistance / lastTouchDistance;
      const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
      
      // Center zoom on touch midpoint
      const centerX = (touch1.clientX + touch2.clientX) / 2 - canvas.getBoundingClientRect().left;
      const centerY = (touch1.clientY + touch2.clientY) / 2 - canvas.getBoundingClientRect().top;
      
      const zoomRatio = newZoom / zoom;
      panX = centerX - (centerX - panX) * zoomRatio;
      panY = centerY - (centerY - panY) * zoomRatio;
      zoom = newZoom;
      
      // Force multiple redraws to prevent artifacts
      requestAnimationFrame(() => {
        draw();
        requestAnimationFrame(() => {
          draw();
        });
      });
    }
    lastTouchDistance = currentDistance;
  }
});

canvas.addEventListener("touchend", (e) => {
  e.preventDefault();
  lastTouchDistance = 0;
});

// ===== Pointer Events Setup =====
// Check if pointer events are supported and add listeners
if (window.PointerEvent) {
  // Use pointer events for unified input handling (mouse, touch, pen)
  // canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("pointermove", handlePointerMove);
  canvas.addEventListener("pointerup", handlePointerUp);
  canvas.addEventListener("pointercancel", handlePointerUp);
  
  // Disable mouse events to prevent double-firing when pointer events are available
  // Note: We keep mouse events as fallback for older browsers
  console.log("Pointer events enabled - pen input supported");
} else {
  console.log("Pointer events not supported - using mouse/touch events only");
}

// ===== Mouse coord transform =====
function getMouse(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Apply inverse zoom and pan transform
  return {
    x: (x - panX) / zoom,
    y: (y - panY) / zoom
  };
}

// ===== Pointer Events (for pen input support) =====
function getPointerPosition(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Apply inverse zoom and pan transform
  return {
    x: (x - panX) / zoom,
    y: (y - panY) / zoom
  };
}

function handlePointerDown(e) {
  // Only handle primary pointer (left mouse button, first touch, pen tip)
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  if (e.pointerType === 'touch' && e.isPrimary === false) return;
  
  // Prevent default to avoid conflicts
  e.preventDefault();
  
  if (isPanMode) return; // Don't handle clicks in pan mode

  // Normal polygon adding/moving
  const {x,y} = getPointerPosition(e);
  // Check if clicking near existing point (account for zoom)
  const hitRadius = 5 / zoom;
  
  // First check if clicking on the start point of the active polygon to close it
  if (activePoly && activePoly.points.length >= 3) {
    const firstPoint = activePoly.points[0];
    if (dist(x,y,firstPoint.x,firstPoint.y) < hitRadius) {
      // Close the polygon (no duplicate point needed - drawing logic handles closing)
      activePoly = null;
      draw(); // Draw to show the closing line
      save();
      return;
    }
  }
  
  // Check if clicking near any existing point
  for (let poly of polygons) {
    for (let pt of poly.points) {
      if (dist(x,y,pt.x,pt.y) < hitRadius) {
        draggingPoint = pt;
        activePoly = poly;
        // Remove saved state when editing a polygon
        removeSavedState();
        return;
      }
    }
  }
  
  // Else: create temporary point that follows mouse
  if (!activePoly) {
    activePoly = {class_id: selectedClassId, points: []};
    polygons.push(activePoly);
  }
  temporaryPoint = {x, y};  // Don't add to polygon yet, just follow mouse
  draw();
}

function handlePointerMove(e) {
  e.preventDefault();
  
  if (isPanMode) {
    // Pan directly when space is held, no click needed
    if (lastPanX !== 0 || lastPanY !== 0) {
      const dx = e.clientX - lastPanX;
      const dy = e.clientY - lastPanY;
      panX += dx;
      panY += dy;
      draw();
    }
    lastPanX = e.clientX;
    lastPanY = e.clientY;
    return;
  }
  
  if (draggingPoint) {
    const {x,y} = getPointerPosition(e);
    draggingPoint.x = x;
    draggingPoint.y = y;
    draw();
  }
}

function handlePointerUp(e) {
  e.preventDefault();
  if (draggingPoint) {
    // Auto-save after dragging a point
    draggingPoint = null;
    save();
  } else {
    draggingPoint = null;
  }
}

function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }

// ===== Drawing =====
function draw() {
  // Update polygon count in status bar
  updatePolygonCount();
  // Completely reset the canvas context
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  
  // Clear the entire canvas with a solid color to prevent artifacts
  ctx.fillStyle = '#2a1a3a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Clear again to ensure clean slate
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.restore();
  
  if (currentImage) {
    // Calculate image position to center it in the viewport
    const imageAspect = currentImage.width / currentImage.height;
    const canvasAspect = canvas.width / canvas.height;
    
    let imageWidth, imageHeight, imageX, imageY;
    
    if (imageAspect > canvasAspect) {
      // Image is wider - fit to width
      imageWidth = canvas.width;
      imageHeight = canvas.width / imageAspect;
      imageX = 0;
      imageY = (canvas.height - imageHeight) / 2;
    } else {
      // Image is taller - fit to height
      imageHeight = canvas.height;
      imageWidth = canvas.height * imageAspect;
      imageX = (canvas.width - imageWidth) / 2;
      imageY = 0;
    }
    
    // Apply zoom and pan transformations using setTransform
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
    
    // Enable image smoothing for better quality
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Draw image at calculated position
    ctx.drawImage(currentImage, imageX, imageY, imageWidth, imageHeight);
  } else {
    // Apply zoom and pan transformations using setTransform
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
  }
  
  ctx.lineWidth = 2 / zoom; // Scale line width with zoom
  polygons.forEach((poly, polyIndex) => {
    const isActive = poly === activePoly;
    const isClosed = !isActive; // Only closed if not currently being drawn
    
    // Generate class-specific color dynamically
    const classColor = generateClassColor(poly.class_id);
    
    // Draw polygon lines (only if closed or active)
    if (!isActive || poly.points.length >= 3) {
      ctx.strokeStyle = classColor;
      ctx.beginPath();
      poly.points.forEach((pt,i) => {
        if (i===0) ctx.moveTo(pt.x,pt.y);
        else ctx.lineTo(pt.x,pt.y);
      });
      // Always close the path to draw the closing line
      ctx.closePath();
      ctx.stroke();
      
      // Only fill if polygon is closed (not currently being drawn)
      if (isClosed) {
        ctx.fillStyle = classColor + "33"; // Add transparency
        ctx.fill();
      }
    }
    
    // Draw points
    const pointSize = 6 / zoom; // Scale point size with zoom
    poly.points.forEach((pt, ptIndex) => {
      if (ptIndex === 0) {
        // First point (start node) - brighter version of class color
        ctx.fillStyle = isActive ? classColor : classColor;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1 / zoom;
        ctx.fillRect(pt.x-pointSize/2, pt.y-pointSize/2, pointSize, pointSize);
        ctx.strokeRect(pt.x-pointSize/2, pt.y-pointSize/2, pointSize, pointSize);
      } else {
        // Regular points
        ctx.fillStyle = classColor;
        ctx.fillRect(pt.x-pointSize/2, pt.y-pointSize/2, pointSize, pointSize);
      }
    });
  });
  
  // Draw temporary point if it exists
  if (temporaryPoint && activePoly) {
    const classColor = generateClassColor(activePoly.class_id);
    const pointSize = 6 / zoom;
    
    // Draw temporary point with a different style to indicate it's temporary
    ctx.fillStyle = classColor;
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2 / zoom;
    ctx.fillRect(temporaryPoint.x-pointSize/2, temporaryPoint.y-pointSize/2, pointSize, pointSize);
    ctx.strokeRect(temporaryPoint.x-pointSize/2, temporaryPoint.y-pointSize/2, pointSize, pointSize);
    
    // Draw line from last point to temporary point if there are existing points
    if (activePoly.points.length > 0) {
      const lastPoint = activePoly.points[activePoly.points.length - 1];
      ctx.strokeStyle = classColor;
      ctx.lineWidth = 2 / zoom;
      ctx.beginPath();
      ctx.moveTo(lastPoint.x, lastPoint.y);
      ctx.lineTo(temporaryPoint.x, temporaryPoint.y);
      ctx.stroke();
    }
  }
}

// ===== Undo Last Point =====
document.getElementById("undoPointBtn").onclick = () => {
  if (activePoly && activePoly.points.length > 0) {
    activePoly.points.pop();
    if (activePoly.points.length === 0) {
      // If no points left, drop polygon entirely
      polygons = polygons.filter(p => p !== activePoly);
      activePoly = null;
    }
    // Remove saved state when editing
    removeSavedState();
    draw();
    // Auto-save after undo
    save();
  }
};

// ===== Delete Current Polygon =====
document.getElementById("deletePolyBtn").onclick = () => {
  if (activePoly) {
    polygons = polygons.filter(p => p !== activePoly);
    activePoly = null;
    // Remove saved state when deleting
    removeSavedState();
    draw();
    // Auto-save after delete
    save();
  }
};

// ===== Save (with auto-clear status) =====
async function save() {
  if (!currentImage) return;
  
  // Only save if there's at least one closed polygon
  const closedPolygons = polygons.filter(poly => poly.points.length >= 3);
  if (closedPolygons.length === 0) {
    const statusMessage = document.getElementById("status-message");
    statusMessage.textContent = "No closed polygons to save";
    statusMessage.classList.add("error");
    setTimeout(() => {
      statusMessage.textContent = "";
      statusMessage.classList.remove("error");
    }, 2000);
    return;
  }
  
  // Calculate image display dimensions (same logic as in draw function)
  const imageAspect = currentImage.width / currentImage.height;
  const canvasAspect = canvas.width / canvas.height;
  
  let imageWidth, imageHeight, imageX, imageY;
  
  if (imageAspect > canvasAspect) {
    // Image is wider - fit to width
    imageWidth = canvas.width;
    imageHeight = canvas.width / imageAspect;
    imageX = 0;
    imageY = (canvas.height - imageHeight) / 2;
  } else {
    // Image is taller - fit to height
    imageHeight = canvas.height;
    imageWidth = canvas.height * imageAspect;
    imageX = (canvas.width - imageWidth) / 2;
    imageY = 0;
  }
  
  const data = {
    image: images[currentImageIndex],
    annotations: closedPolygons.map(p => ({
      class_id: p.class_id,
      points: p.points.map(pt => [
        (pt.x - imageX) / imageWidth,
        (pt.y - imageY) / imageHeight
      ])
    }))
  };
  
  try {
    const response = await fetch("/save", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const errorMsg = errorData.error || `${response.status} ${response.statusText}`;
      throw new Error(`Save failed: ${errorMsg}`);
    }
    
    const result = await response.json();
    const statusMessage = document.getElementById("status-message");
    statusMessage.textContent = "Saved!";
    statusMessage.classList.remove("error");
    setTimeout(() => statusMessage.textContent = "", 2000);
    
    // Refresh image list to update label status
    debounceUpdateImageList();
  } catch (error) {
    console.error('Save error:', error);
    const statusMessage = document.getElementById("status-message");
    statusMessage.textContent = `Save failed: ${error.message}`;
    statusMessage.classList.add("error");
    setTimeout(() => {
      statusMessage.textContent = "";
      statusMessage.classList.remove("error");
    }, 5000);
  }
}

// ===== Remove Saved State =====
function removeSavedState() {
  const statusMessage = document.getElementById("status-message");
  statusMessage.textContent = "Editing...";
  statusMessage.classList.remove("error");
  setTimeout(() => statusMessage.textContent = "", 1000);
}

// ===== Status Bar Updates =====
function updateImageFilename() {
  const filenameElement = document.getElementById("image-filename");
  if (images && images.length > 0 && currentImageIndex >= 0 && currentImageIndex < images.length) {
    filenameElement.textContent = images[currentImageIndex];
  } else {
    filenameElement.textContent = "No image loaded";
  }
}

function updateZoomInfo() {
  const zoomElement = document.getElementById("zoom-info");
  zoomElement.textContent = `Zoom: ${Math.round(zoom * 100)}%`;
}

function updatePolygonCount() {
  const polygonElement = document.getElementById("polygon-count");
  polygonElement.textContent = `Polygons: ${polygons.length}`;
}

async function saveEmptyLabels() {
  if (!currentImage) return;
  
  const data = {
    image: images[currentImageIndex],
    annotations: []
  };
  
  try {
    const response = await fetch("/save", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify(data)
    });
    
    // Refresh image list to show empty state
    setTimeout(() => debounceUpdateImageList(), 500);
  } catch (error) {
    console.error('Save empty labels error:', error);
  }
}

function updateStatusBar() {
  updateImageFilename();
  updateZoomInfo();
  updatePolygonCount();
}

// ===== Keyboard Shortcuts =====
document.addEventListener("keydown", (e) => {
  // Prevent shortcuts when typing in input fields
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  // Prevent space from scrolling image list when used for panning
  if (e.code === "Space") {
    e.preventDefault();
    if (!isPanMode) {
      isPanMode = true;

      canvas.style.cursor = "grab";
      lastPanX = 0;
      lastPanY = 0;
    }
  }
  
  switch(e.key.toLowerCase()) {
    case 'z':
      e.preventDefault();
      document.getElementById("undoPointBtn").click();
      break;
    case 'x':
      e.preventDefault();
      document.getElementById("deletePolyBtn").click();
      break;
    case 's':
      e.preventDefault();
      document.getElementById("saveBtn").click();
      break;
    case 'b':
      e.preventDefault();
      document.getElementById("prevBtn").click();
      break;
    case 'n':
      e.preventDefault();
      document.getElementById("nextBtn").click();
      break;
    case 'arrowleft':
      e.preventDefault();
      document.getElementById("prevBtn").click();
      break;
    case 'arrowright':
      e.preventDefault();
      document.getElementById("nextBtn").click();
      break;
    case '-':
    case '_': // Handle shift+- for underscore
      e.preventDefault();
      document.getElementById("zoomOutBtn").click();
      break;
    case '=':
    case '+': // Handle shift+= for plus
      e.preventDefault();
      document.getElementById("zoomInBtn").click();
      break;
    case 'r':
    case 'R':
      e.preventDefault();
      // Check if we have more than 13 classes, otherwise R is for zoom reset
      if (classes.length > 13) {
        const classId = 13; // R key selects class 13
        selectClass(classId);
      } else {
        document.getElementById("resetZoomBtn").click();
      }
      break;
    default:
      // Number keys 1-9 and 0 for class selection
      if (e.key >= '1' && e.key <= '9') {
        const classId = parseInt(e.key) - 1;
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === '0') {
        const classId = 9; // 0 key selects class 9 (10th class)
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      }
      // Additional keys for more than 10 classes
      else if (e.key === 'q' || e.key === 'Q') {
        const classId = 10; // Q key selects class 10
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'w' || e.key === 'W') {
        const classId = 11; // W key selects class 11
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'e' || e.key === 'E') {
        const classId = 12; // E key selects class 12
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 't' || e.key === 'T') {
        const classId = 14; // T key selects class 14
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'y' || e.key === 'Y') {
        const classId = 15; // Y key selects class 15
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'u' || e.key === 'U') {
        const classId = 16; // U key selects class 16
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'i' || e.key === 'I') {
        const classId = 17; // I key selects class 17
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'o' || e.key === 'O') {
        const classId = 18; // O key selects class 18
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === 'p' || e.key === 'P') {
        const classId = 19; // P key selects class 19
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      }
      break;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.code === "Space") {
    isPanMode = false;
    canvas.style.cursor = "crosshair";
    lastPanX = 0;
    lastPanY = 0;
  }
});

// ===== Navigation =====
document.getElementById("nextBtn").onclick = () => loadImage(currentImageIndex+1);
document.getElementById("prevBtn").onclick = () => loadImage(currentImageIndex-1);
document.getElementById("saveBtn").onclick = save;

// ===== Zoom Controls =====
function zoomIn() {
  const newZoom = Math.min(5, zoom * 1.2);
  zoom = newZoom;
  updateZoomInfo();
  // Force multiple redraws for better rendering
  requestAnimationFrame(() => {
    draw();
    requestAnimationFrame(() => draw());
  });
}

function zoomOut() {
  const newZoom = Math.max(0.1, zoom / 1.2);
  zoom = newZoom;
  updateZoomInfo();
  // Force multiple redraws for better rendering
  requestAnimationFrame(() => {
    draw();
    requestAnimationFrame(() => draw());
  });
}

function resetZoom() {
  zoom = 1;
  panX = 0;
  panY = 0;
  updateZoomInfo();
  // Force multiple redraws for better rendering
  requestAnimationFrame(() => {
    draw();
    requestAnimationFrame(() => draw());
  });
}

document.getElementById("zoomInBtn").onclick = zoomIn;
document.getElementById("zoomOutBtn").onclick = zoomOut;
document.getElementById("resetZoomBtn").onclick = resetZoom;

init();
</script>
</body>
</html>
