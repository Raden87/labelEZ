<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YOLO Polygon Labeler</title>
  <style>
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 0; 
      height: 100vh; 
      overflow: hidden;
      background: #2a1a3a;
    }
    
    #canvas-container { 
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    canvas { 
      cursor: crosshair; 
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }
    
    #left-toolbox {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 6px;
      border-radius: 4px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100px;
    }
    
    #right-toolbox {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 6px;
      border-radius: 4px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100px;
    }
    
    .toolbox-section {
      margin-bottom: 10px;
    }
    
    .toolbox-section:last-child {
      margin-bottom: 0;
    }
    
    .toolbox-section h3 {
      color: white;
      margin: 0 0 5px 0;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button { 
      padding: 5px 4px; 
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 500;
      transition: all 0.2s;
      width: 100%;
      margin-bottom: 3px;
    }
    
    button:last-child {
      margin-bottom: 0;
    }
    
    .action-btn {
      background: #4a90e2;
      color: white;
    }
    
    .action-btn:hover {
      background: #357abd;
    }
    
    .class-btn {
      background: #666;
      color: white;
      padding: 4px 3px;
      font-size: 9px;
      border: 1px solid transparent;
      text-align: left;
    }
    
    .class-btn:hover {
      background: #888;
    }
    
    .class-btn.active {
      border: 2px solid white;
    }
    
    /* Class-specific colors will be generated dynamically */
    
    .nav-btn {
      background: #28a745;
      color: white;
    }
    
    .nav-btn:hover {
      background: #218838;
    }
    
    #status {
      color: #4a90e2;
      font-size: 9px;
      margin: 0;
      text-align: center;
      padding: 4px;
      background: rgba(74, 144, 226, 0.1);
      border-radius: 2px;
      border: 1px solid rgba(74, 144, 226, 0.3);
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>

  <div id="left-toolbox">
    <div class="toolbox-section">
      <h3>Actions</h3>
      <button id="saveBtn" class="action-btn">Save (S)</button>
      <button id="undoPointBtn" class="action-btn">Undo (Z)</button>
      <button id="deletePolyBtn" class="action-btn">Delete (X)</button>
    </div>
    
    <div class="toolbox-section">
      <h3>Navigation</h3>
      <button id="prevBtn" class="nav-btn">Back (B)</button>
      <button id="nextBtn" class="nav-btn">Next (N)</button>
    </div>
    
    <div class="toolbox-section">
      <h3>Status</h3>
      <p id="status"></p>
    </div>
  </div>

  <div id="right-toolbox">
    <div class="toolbox-section">
      <h3>Classes</h3>
      <div id="classButtons">
        <!-- Class buttons will be generated here -->
      </div>
    </div>
  </div>

<script>
let classes = [];
let images = [];
let currentImageIndex = 0;
let currentImage = null;
let polygons = [];  // {class_id, points:[{x,y}]}
let activePoly = null;
let draggingPoint = null;
let selectedClassId = 0;

// Zoom and pan state
let zoom = 1;
let panX = 0;
let panY = 0;
let isPanMode = false;   // true when space held
let isDraggingPan = false;
let lastPanX = 0;
let lastPanY = 0;

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// ===== Color Generation =====
function generateClassColor(classIndex) {
  // Generate a color using HSL for better distribution
  const hue = (classIndex * 137.5) % 360; // Golden angle for good distribution
  const saturation = 70 + (classIndex % 3) * 10; // Vary saturation slightly
  const lightness = 45 + (classIndex % 2) * 10; // Vary lightness slightly
  
  // Convert HSL to RGB
  const h = hue / 360;
  const s = saturation / 100;
  const l = lightness / 100;
  
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs((h * 6) % 2 - 1));
  const m = l - c / 2;
  
  let r, g, b;
  if (h < 1/6) { r = c; g = x; b = 0; }
  else if (h < 2/6) { r = x; g = c; b = 0; }
  else if (h < 3/6) { r = 0; g = c; b = x; }
  else if (h < 4/6) { r = 0; g = x; b = c; }
  else if (h < 5/6) { r = x; g = 0; b = c; }
  else { r = c; g = 0; b = x; }
  
  r = Math.round((r + m) * 255);
  g = Math.round((g + m) * 255);
  b = Math.round((b + m) * 255);
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// ===== Load classes and images =====
async function init() {
  classes = await fetch("/classes").then(r => r.json());
  images = await fetch("/images").then(r => r.json());

  // Create class buttons with dynamic colors
  let classButtons = document.getElementById("classButtons");
  classes.forEach((c, i) => {
    let btn = document.createElement("button");
    btn.className = "class-btn";
    btn.setAttribute("data-class", i);
    btn.textContent = `${i + 1}: ${c}`;
    btn.style.backgroundColor = generateClassColor(i);
    btn.onclick = () => selectClass(i);
    classButtons.appendChild(btn);
  });

  // Select first class by default
  selectClass(0);
  loadImage(0);
}

// ===== Class Selection =====
function selectClass(classId) {
  selectedClassId = classId;
  // Update button states
  document.querySelectorAll('.class-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === classId);
  });
}

async function loadImage(idx) {
  if (idx < 0 || idx >= images.length) return;
  
  // Auto-save before changing images if there are polygons
  if (polygons.length > 0) {
    save();
  }
  
  currentImageIndex = idx;
  polygons = [];
  // Keep zoom and pan state persistent across images
  // zoom = 1;
  // panX = 0;
  // panY = 0;
  
  const img = new Image();
  img.onload = async () => {
    currentImage = img;
    // Set canvas size to fill viewport
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Load existing labels for this image
    await loadExistingLabels(images[idx]);
    
    // Force multiple redraws to prevent artifacts
    requestAnimationFrame(() => {
      draw();
      requestAnimationFrame(() => {
        draw();
      });
    });
  };
  img.src = "/image/" + images[idx];
}

// ===== Load Existing Labels =====
async function loadExistingLabels(imageName) {
  try {
    const response = await fetch(`/load/${imageName}`);
    const annotations = await response.json();
    
    // Convert normalized coordinates back to canvas coordinates
    polygons = annotations.map(ann => ({
      class_id: ann.class_id,
      points: ann.points.map(pt => ({
        x: pt[0] * canvas.width,
        y: pt[1] * canvas.height
      }))
    }));
    
    // Clear active polygon since we're loading existing ones
    activePoly = null;
    
    console.log(`Loaded ${polygons.length} existing polygons for ${imageName}`);
  } catch (error) {
    console.error('Error loading existing labels:', error);
    polygons = [];
  }
}

// ===== Mouse Events =====
canvas.addEventListener("mousedown", (e) => {
  if (isPanMode) return; // Don't handle clicks in pan mode

  // Normal polygon adding/moving
  const {x,y} = getMouse(e);
  // Check if clicking near existing point (account for zoom)
  const hitRadius = 5 / zoom;
  
  // First check if clicking on the start point of the active polygon to close it
  if (activePoly && activePoly.points.length >= 3) {
    const firstPoint = activePoly.points[0];
    if (dist(x,y,firstPoint.x,firstPoint.y) < hitRadius) {
      // Close the polygon (no duplicate point needed - drawing logic handles closing)
      activePoly = null;
      draw(); // Draw to show the closing line
      save();
      return;
    }
  }
  
  // Check if clicking near any existing point
  for (let poly of polygons) {
    for (let pt of poly.points) {
      if (dist(x,y,pt.x,pt.y) < hitRadius) {
        draggingPoint = pt;
        activePoly = poly;
        // Remove saved state when editing a polygon
        removeSavedState();
        return;
      }
    }
  }
  
  // Else: add new point to active polygon or start new
  if (!activePoly) {
    activePoly = {class_id: selectedClassId, points: []};
    polygons.push(activePoly);
  }
  activePoly.points.push({x,y});
  draw();
});

canvas.addEventListener("mousemove", (e) => {
  if (isPanMode) {
    // Pan directly when space is held, no click needed
    if (lastPanX !== 0 || lastPanY !== 0) {
      const dx = e.clientX - lastPanX;
      const dy = e.clientY - lastPanY;
      panX += dx;
      panY += dy;
      draw();
    }
    lastPanX = e.clientX;
    lastPanY = e.clientY;
    return;
  }
  
  if (draggingPoint) {
    const {x,y} = getMouse(e);
    draggingPoint.x = x;
    draggingPoint.y = y;
    draw();
  }
});

canvas.addEventListener("mouseup", () => {
  if (draggingPoint) {
    // Auto-save after dragging a point
    draggingPoint = null;
    save();
  } else {
    draggingPoint = null;
  }
});

// ===== Zoom =====
canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));

  // Adjust pan so zoom is centered at mouse
  const zoomRatio = newZoom / zoom;
  panX = mouseX - (mouseX - panX) * zoomRatio;
  panY = mouseY - (mouseY - panY) * zoomRatio;
  zoom = newZoom;

  // Force multiple redraws to prevent artifacts
  requestAnimationFrame(() => {
    draw();
    requestAnimationFrame(() => {
      draw();
    });
  });
});

// Touch support for pinch zoom
let lastTouchDistance = 0;
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    lastTouchDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
  }
});

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
    
    if (lastTouchDistance > 0) {
      const zoomFactor = currentDistance / lastTouchDistance;
      const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
      
      // Center zoom on touch midpoint
      const centerX = (touch1.clientX + touch2.clientX) / 2 - canvas.getBoundingClientRect().left;
      const centerY = (touch1.clientY + touch2.clientY) / 2 - canvas.getBoundingClientRect().top;
      
      const zoomRatio = newZoom / zoom;
      panX = centerX - (centerX - panX) * zoomRatio;
      panY = centerY - (centerY - panY) * zoomRatio;
      zoom = newZoom;
      
      // Force multiple redraws to prevent artifacts
      requestAnimationFrame(() => {
        draw();
        requestAnimationFrame(() => {
          draw();
        });
      });
    }
    lastTouchDistance = currentDistance;
  }
});

canvas.addEventListener("touchend", (e) => {
  e.preventDefault();
  lastTouchDistance = 0;
});

// ===== Mouse coord transform =====
function getMouse(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Apply inverse zoom and pan transform
  return {
    x: (x - panX) / zoom,
    y: (y - panY) / zoom
  };
}

function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }

// ===== Drawing =====
function draw() {
  // Completely reset the canvas context
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  
  // Clear the entire canvas with a solid color to prevent artifacts
  ctx.fillStyle = '#2a1a3a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Clear again to ensure clean slate
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.restore();
  
  if (currentImage) {
    // Calculate image position to center it in the viewport
    const imageAspect = currentImage.width / currentImage.height;
    const canvasAspect = canvas.width / canvas.height;
    
    let imageWidth, imageHeight, imageX, imageY;
    
    if (imageAspect > canvasAspect) {
      // Image is wider - fit to width
      imageWidth = canvas.width;
      imageHeight = canvas.width / imageAspect;
      imageX = 0;
      imageY = (canvas.height - imageHeight) / 2;
    } else {
      // Image is taller - fit to height
      imageHeight = canvas.height;
      imageWidth = canvas.height * imageAspect;
      imageX = (canvas.width - imageWidth) / 2;
      imageY = 0;
    }
    
    // Apply zoom and pan transformations using setTransform
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
    
    // Enable image smoothing for better quality
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Draw image at calculated position
    ctx.drawImage(currentImage, imageX, imageY, imageWidth, imageHeight);
  } else {
    // Apply zoom and pan transformations using setTransform
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
  }
  
  ctx.lineWidth = 2 / zoom; // Scale line width with zoom
  polygons.forEach((poly, polyIndex) => {
    const isActive = poly === activePoly;
    const isClosed = !isActive; // Only closed if not currently being drawn
    
    // Generate class-specific color dynamically
    const classColor = generateClassColor(poly.class_id);
    
    // Draw polygon lines (only if closed or active)
    if (!isActive || poly.points.length >= 3) {
      ctx.strokeStyle = classColor;
      ctx.beginPath();
      poly.points.forEach((pt,i) => {
        if (i===0) ctx.moveTo(pt.x,pt.y);
        else ctx.lineTo(pt.x,pt.y);
      });
      // Always close the path to draw the closing line
      ctx.closePath();
      ctx.stroke();
      
      // Only fill if polygon is closed (not currently being drawn)
      if (isClosed) {
        ctx.fillStyle = classColor + "33"; // Add transparency
        ctx.fill();
      }
    }
    
    // Draw points
    const pointSize = 6 / zoom; // Scale point size with zoom
    poly.points.forEach((pt, ptIndex) => {
      if (ptIndex === 0) {
        // First point (start node) - brighter version of class color
        ctx.fillStyle = isActive ? classColor : classColor;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1 / zoom;
        ctx.fillRect(pt.x-pointSize/2, pt.y-pointSize/2, pointSize, pointSize);
        ctx.strokeRect(pt.x-pointSize/2, pt.y-pointSize/2, pointSize, pointSize);
      } else {
        // Regular points
        ctx.fillStyle = classColor;
        ctx.fillRect(pt.x-pointSize/2, pt.y-pointSize/2, pointSize, pointSize);
      }
    });
  });
}

// ===== Undo Last Point =====
document.getElementById("undoPointBtn").onclick = () => {
  if (activePoly && activePoly.points.length > 0) {
    activePoly.points.pop();
    if (activePoly.points.length === 0) {
      // If no points left, drop polygon entirely
      polygons = polygons.filter(p => p !== activePoly);
      activePoly = null;
    }
    // Remove saved state when editing
    removeSavedState();
    draw();
    // Auto-save after undo
    save();
  }
};

// ===== Delete Current Polygon =====
document.getElementById("deletePolyBtn").onclick = () => {
  if (activePoly) {
    polygons = polygons.filter(p => p !== activePoly);
    activePoly = null;
    // Remove saved state when deleting
    removeSavedState();
    draw();
    // Auto-save after delete
    save();
  }
};

// ===== Save (with auto-clear status) =====
async function save() {
  if (!currentImage) return;
  const data = {
    image: images[currentImageIndex],
    annotations: polygons.map(p => ({
      class_id: p.class_id,
      points: p.points.map(pt => [
        pt.x / canvas.width,
        pt.y / canvas.height
      ])
    }))
  };
  await fetch("/save", {
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify(data)
  });
  const status = document.getElementById("status");
  status.textContent = "Saved!";
  setTimeout(() => status.textContent = "", 2000);
}

// ===== Remove Saved State =====
function removeSavedState() {
  const status = document.getElementById("status");
  status.textContent = "Editing...";
  setTimeout(() => status.textContent = "", 1000);
}

// ===== Keyboard Shortcuts =====
document.addEventListener("keydown", (e) => {
  // Prevent shortcuts when typing in input fields
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  // Track space key for panning
  if (e.code === "Space" && !isPanMode) {
    isPanMode = true;
    canvas.style.cursor = "grab";
    lastPanX = 0;
    lastPanY = 0;
    e.preventDefault();
  }
  
  switch(e.key.toLowerCase()) {
    case 'z':
      e.preventDefault();
      document.getElementById("undoPointBtn").click();
      break;
    case 'x':
      e.preventDefault();
      document.getElementById("deletePolyBtn").click();
      break;
    case 's':
      e.preventDefault();
      document.getElementById("saveBtn").click();
      break;
    case 'b':
      e.preventDefault();
      document.getElementById("prevBtn").click();
      break;
    case 'n':
      e.preventDefault();
      document.getElementById("nextBtn").click();
      break;
    case 'arrowleft':
      e.preventDefault();
      document.getElementById("prevBtn").click();
      break;
    case 'arrowright':
      e.preventDefault();
      document.getElementById("nextBtn").click();
      break;
    default:
      // Number keys 1-9 and 0 for class selection
      if (e.key >= '1' && e.key <= '9') {
        const classId = parseInt(e.key) - 1;
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      } else if (e.key === '0') {
        const classId = 9; // 0 key selects class 9 (10th class)
        if (classId < classes.length) {
          e.preventDefault();
          selectClass(classId);
        }
      }
      break;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.code === "Space") {
    isPanMode = false;
    canvas.style.cursor = "crosshair";
    lastPanX = 0;
    lastPanY = 0;
  }
});

// ===== Navigation =====
document.getElementById("nextBtn").onclick = () => loadImage(currentImageIndex+1);
document.getElementById("prevBtn").onclick = () => loadImage(currentImageIndex-1);
document.getElementById("saveBtn").onclick = save;

init();
</script>
</body>
</html>
